\chapter{Considerações finais}\label{cap:final_considerations}

Mediante uma revisão estruturada na literatura científica, em busca de um modelo consistente de classificação de defeitos de software, encontramos alguns trabalhos que utilizam a classificação ODC (veja o \Cref{cap:cientific_library_research}), que leva em consideração a causa raiz do defeito com uma boa referência no ponto de vista de desenvolvimento. Logo, ela se mostra útil para classificarmos as ocorrências encontrados em uma aplicação real.

Esta análise das ocorrências, que envolve a contagem, agrupamento e análise dos erros mais comuns conforme a classificação encontrada anteriormente, nos permite entender que os erros mais frequentes estão diretamente relacionados com o processo de desenvolvimento. Isto nos leva a analisá-las mais a fundo para entender se existem práticas que mitiguem a ocorrência destes erros. Feito isso, analisamos possíveis abordagens, estratégias de desenvolvimento e ferramentas que possam ajudar neste processo.

No caso da escolha da linguagem, consideramos Java e Kotlin para uma comparação prática de como o Kotlin permite facilmente sobrepor alguns comportamentos que oferecem justamente o risco de ocorrências dos erros mais comuns encontrados na aplicação de exemplo. Do ponto de vista de técnicas de programação, foram propostas técnicas de controle de fluxo que também pode ajudar a capturar e tratar da forma correta eventos de erro, fugindo do paradigma mais comum que seria o tratamento de exceções, em Java. Já do ponto de vista de ferramentas, os \textit{linters}, se empregados corretamente, podem colaborar ainda mais e de forma automatizada para diminuir a probabilidade de que erros não esperados ocorram na aplicação em produção.

Como prova de conceito, a ferramente de \textit{linter} \textit{detekt} foi implementada em uma aplicação em Kotlin de forma acoplada ao seu processo de verificação e \textit{build}. Inclusive, durante a etapa de migração deste projeto de Java para Kotlin, diversas melhorias foram feitas a partir de relatórios extraídos da ferramenta em questão.

Em trabalhos futuros, podemos ampliar a pesquisa e analisar se, através da mineração de repositórios públicos, os defeitos mais comuns encontrados corroboram com os resultados aqui obtidos. Podemos também analisar \textit{issues} e correções nestes repositórios, aplicando modelos de trabalhos anteriores e aplicar resultados nos processos aqui realizados. Em paralelo a isso, podemos demonstrar outros indicadores quem demonstrem ganhos reais com a aplicação das abordagens propostas neste trabalho. Desta forma, podemos consolidar os pontos aqui propostos e ampliarmos as possibilidades de mitigação dos erros encontrados.
